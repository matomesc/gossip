<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/node.js - Gossip</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Gossip"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Cluster.html">Cluster</a></li>
            
                <li><a href="../classes/Hub.html">Hub</a></li>
            
                <li><a href="../classes/Message.html">Message</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/utils.html">utils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/core.html">core</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: core/node.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var assert = require(&#x27;assert&#x27;);
var EventEmitter = require(&#x27;events&#x27;).EventEmitter;
var zmq = require(&#x27;zmq&#x27;);
var uuid = require(&#x27;node-uuid&#x27;);
var __stack = require(&#x27;callsite&#x27;);
var utils = require(&#x27;./utils&#x27;);
var protocol = require(&#x27;./protocol&#x27;);
var Message = require(&#x27;./message&#x27;);
var MessageFactory = require(&#x27;./message_factory&#x27;);
var Hub = require(&#x27;./hub&#x27;);

var keys = Object.keys;

/**
 * The node is the building block of gossip.
 *
 * Each node consists of a hub. A hub an abstraction built out of a router and pub socket that allows
 * 1-N request-reply and fire-forget messaging.
 *
 * @class   Node
 * @module  core
 * @param   {Object|String} [options]
 * @param   {String}        [options.id]                 Should uniquely identify the node in the cluster.
 * @param   {Object}        [options.endpoints]
 * @param   {String}        [options.endpoints.router]   The router socket to bind to (ipc://..., tcp://...).
 * @param   {String}        [options.endpoints.pub]      The pub socket to bind to.
 * @param   {String}        [options.name]               A name for the node, not necessarily unique.
 * @param   {Object}        [options.keepalive]
 * @param   {Number}        [options.keepalive.period]   How often to send keepalives to the cluster.
 * @constructor
 */
function Node(options) {

  /**
   * @property  options
   * @type      Object
   */
  this.options = {};

  if (typeof options === &#x27;string&#x27;) {
    // endpoint of other node&#x27;s hub router
    this.options = {
      hub: {
        router: options
      }
    };
  } else {
    this.options = options;
  }

  if (!this.options.hub || !this.options.hub.router) {
    throw new Error(&#x27;missing hub router endpoint&#x27;);
  }

  // set default options
  this.options.hub.pub = this.options.hub.pub || protocol.pubFromRouter(this.options.hub.router);
  this.options.keepalive = this.options.keepalive || Node.DEFAULT_KEEPALIVE_PERIOD;

  /**
   * @property  hub
   * @type      Hub
   */
  this.hub = new Hub();



  // old stuff

  this.id = (options &amp;&amp; options.id) || uuid.v4();
  this.socketId = Node.buildSocketId(this.id);
  this.name = (options &amp;&amp; options.name) || &#x27;node-&#x27; + this.id;

  var endpoints = options &amp;&amp; options.endpoints;

  this.endpoints = {
    router: (endpoints &amp;&amp; endpoints.router) || &#x27;ipc:///tmp/router-&#x27; + this.id,
    pub: (endpoints &amp;&amp; endpoints.pub) || &#x27;ipc:///tmp/pub-&#x27; + this.id
  };

  this.keepalive = {
    // how often this node will notify the cluster of it&#x27; liveness
    // if we don&#x27;t send any keep alives
    // the node attempts to send 3 keepalives per period
    period: (options &amp;&amp; options.keepalive &amp;&amp; options.keepalive.period) || 1000
  };

  // message types that this node has subscribed through a call to &#x60;.on()&#x60;
  // by default every node is subscribed to a few internal messages:
  //
  // _ping: emitted when a new node in the cluster sends us their info, should reply with _pong
  // _pong: emitted when an existing node replies with the cluster info
  // _ka: emitted when receiving keepalives from other nodes
  //
  // internal subscriptions are created in &#x60;_initListeners()&#x60;
  //
  this.messages = {};

  this._msgFactory = new MessageFactory({
    id: uuid.v4,    // message id
    src: this.id    // node id
  });

  // the long we think it takes us to reply to message
  // nodes in the cluster will then expect you to reply within this time,
  // otherwise the sending node will retry
  // you can set the default by passing in &#x60;options.reply.period&#x60; or per message type
  // with &#x60;.on(&#x27;something&#x27;, { period: 5000 },  )&#x60;
  this._defaultReplyPeriod = (options &amp;&amp; options.reply &amp;&amp; options.reply.period) || 5000;

  // if we send a message and we expect a reply back, this is the max
  // number of retries we will automatically do before giving up
  // if the node that we expect a reply back from fails to heartbeat, then
  // we quit early
  this._defaultReplyAttempts = (options &amp;&amp; options.reply &amp;&amp; options.reply.attempts) || 3;

  // zmq sockets
  // these are initialized in &#x60;_initSockets()&#x60;
  this._routerSocket = zmq.socket(&#x27;router&#x27;);
  this._pubSocket = zmq.socket(&#x27;pub&#x27;);
  this._subSocket = zmq.socket(&#x27;sub&#x27;);

  // cluster map by node id
  this._cluster = {};

  // another map of the cluster, but by message type
  // used internally by &#x60;.send()&#x60; to load balance messages randomly
  this._clusterByMsg = {};

  // nodes that we are connected to by id
  this._connectedTo = {};

  this._clusterKeepalive = {};

  // will periodically check &#x60;this._clusterKeepalive&#x60; and remove nodes
  // whose keepalive expired
  this._keepalivePruneTimer = null;

  // this will periodically send keepalives to the cluster
  this._keepaliveSendTimer = null;

  this._internalEmitter = new EventEmitter();

  // this emits all messages received from the cluster
  // used by &#x60;.on()&#x60; and &#x60;.off()&#x60;
  this._msgEmitter = new EventEmitter();

  // we use these to prevent the slow joiner syndrome
  this._defaultPubDelay = 200; // milliseconds
  // any calls to &#x60;.send&#x60;
  this._pubQueue = [];
  this._shouldQueuePub = true;

  // internally used to save handlers for calls to other nodes
  this._pendingReplies = {};

  // if &#x60;.join()&#x60; is called before &#x60;.start()&#x60; then
  // we add all the nodes to the queue
  this._connectQueue = [];

  // clear the pub queue after the default delay expires
  // prevents slow joiner symptom of sub sockets
  setTimeout(this._clearPubQueue, this._defaultPubDelay);

  this._state = Node.STOPPED;
}

/*********************************************
 * Public API
 *********************************************/

/**
 * Starts the node.
 *
 * Internally, it initializes the sockets and internal listeners, transitions the node the &#x60;STARTED&#x60; state
 * and flushes queued &#x60;join()&#x60; calls.
 *
 * @method start
 * @return {Node}
 * @chainable
 */
Node.prototype.start = function () {
  if (this._state === Node.STOPPED) {
    this._initSockets();
    this._initListeners();
    this._state = Node.STARTED;
    this._emit(&#x27;started&#x27;);

    if (this._connectQueue.length) {
      this._drainConnectQueue();
    }
  }

  return this;
};

/**
 * Stops the node. Once a node is stopped, it can&#x27;t be started again.
 * If you want to temporarily stop receiving messages, see &#x60;.pause()&#x60; and &#x60;.unpause()&#x60;.
 *
 * This removes all message listeners and the node transitions to the STOPPED state.
 *
 * @method stop
 * @return {Node}
 * @chainable
 */
Node.prototype.stop = function () {
  if (this._state !== Node.STOPPED) {
    this._closeSockets();
    this.off();
    this._state = Node.STOPPED;
    this._emit(&#x27;stopped&#x27;);
  }

  return this;
};

/**
 * Join a cluster.
 *
 * You must specifiy either a node object or the configuration of a node
 * already in the cluster.
 *
 * @param   {Object|Node} node
 * @param   {String}      node.id
 * @param   {String}      node.endpoints.router
 * @param   {String}      node.endpoints.pub
 * @param   {Function}    cb
 * @return  {Node}
 */
Node.prototype.join = function (node, cb) {
  var self = this;

  if (node instanceof Node) {
    node = node.getInfo();
  }

  if (self._state === Node.STOPPED) {
    // queue connects requests - these are eventually drained by &#x60;_drainConnectQueue()&#x60;
    self._connectQueue.push([node, cb]);
    return self;
  }

  self._addNodeToCluster(node);

//  self._logInfo(&#x27;about to send _join message&#x27;);

  self.sendTo(node.id, &#x27;_join&#x27;, self.getInfo(), function (err, msg) {
//    self._logInfo(&#x27;inside join()&#x27;);
//    self._logInfo(err, msg);
    if (err) {
      self._removeNodeFromCluster(node.id);
      return cb(err);
    }

    // save the node that replied to us
    self._addNodeToCluster(msg.data.me);

    // contact the rest of the cluster
    var data = self.getInfo();
    keys(msg.data.cluster).forEach(function (id) {
      // don&#x27;t connect to ourselves
      if (self.id === id) {
        return;
      }

      var other = msg.data.cluster[id];

      self._addNodeToCluster(other);

      self.sendTo(id, &#x27;_connect&#x27;, data, function (err, msg) {
        if (err) {
          console.log(&#x27;failed to connect to&#x27;, id, &#x27;:&#x27;);
          console.log(err.stack);
          self._disconnectNode(node);
        } else {
          self._addNodeToCluster(msg.data);
          console.log(&#x27;connected to&#x27;, id);
        }
      });
    });

    return cb(null);
  });

  return self;
};

// TODO
Node.prototype.pause = function () {

};

// TODO
Node.prototype.unpause = function () {

};

/**
 * Subscribe to messages from other nodes.
 *
 * @method  on
 * @param   {String}            type                The type of message.
 * @param   {Object|Function}   [options]
 * @param   {Number}            [options.period]    Maximum time another node will wait for an answer before retrying.
 * @param   {Number}            [options.attempts]  Maximum attempts
 * @param   {Function}          cb                  Callback to execute when a message is received.
 * @return  {Node}
 * @chainable
 */
Node.prototype.on = function (type, options, cb) {
  if (arguments.length === 2) {
    cb = options;
    options = {};
  }

  this._msgEmitter.on(type, cb);

  this.messages[type] = {
    period: (options &amp;&amp; options.period) || this._defaultReplyPeriod,
    attempts: (options &amp;&amp; options.attempts) || this._defaultReplyAttempts
  };

  return this;
};

/**
 * Unsubscribe from messages from other nodes.
 *
 * @param  {String}   [msgType] The type of message to unsubscribe from. If not specified,
 *                              unsubscribes from all messages.
 * @param  {Function} [cb]      The listener to remove. If not specified, removes all
 *                              listeners.
 * @return {Node}
 * @chainable
 */
Node.prototype.off = function (msgType, cb) {
  if (cb) {
    this._msgEmitter.removeListener(msgType, cb);
    if (this._msgEmitter.listeners(msgType).length === 0) {
      delete this.messages[msgType];
    }
  } else if (msgType) {
    this._msgEmitter.removeAllListeners(msgType);
    delete this.messages[msgType];
  } else {
    this._msgEmitter.removeAllListeners();
    this.messages = {};
  }

  return this;
};

/**
 * Send a message that will be load balanced across all other nodes that are
 * interested in the message.
 *
 * @param   {String}   type   The type of message to send.
 * @param   {Object}   data
 * @param   {Function} cb     Called with &#x60;(error, [reply])&#x60;
 * @return  {Node}
 * @chainable
 */
Node.prototype.send = function (type, data, cb) {
  if (!this._clusterByMsg[type]) {
    return cb(new Error(&#x27;nobody cares about that message type&#x27;));
  }

  // randomly generate the id of the node we will send to
  var dest = utils.randRange(0, this._clusterByMsg[type].length);

  return this.sendTo(dest, type, data, cb);
};

/**
 * Send a message to a specific node.
 *
 * TODO: check if &#x60;cb.length === 1&#x60; and don&#x27;t attach reply handler
 * TODO: this &#x60;.reply()&#x60; should delegate to the same method
 *
 * @param {String}    id
 * @param {String}    type
 * @param {*}         [data]
 * @param {Function}  cb
 * @chainable
 */
Node.prototype.sendTo = function (id, type, data, cb) {
  if (!this._cluster[id]) {
    return cb(new Error(&#x27;no such node&#x27;));
  }

  if (arguments.length === 3) {
    cb = data;
    data = undefined;
  }

  var idBuf = this._cluster[id].socketId;
  var msg = this._msgFactory.build({
    dest: id,
    type: type,
    data: data
  });

//  this._logInfo(&#x27;in sendTo():&#x27;);
//  this._logInfo(&#x27;arguments:&#x27;, arguments);
//  this._logInfo(&#x27;destination socket id:&#x27;, idBuf.toString());
//  this._logInfo(msg);

//  console.log(idBuf);
//  console.log(&#x27;sendTo():&#x27;, msg.raw().toString());

  if (cb.length === 2) {
    this._addReplyHandler(msg.body(), cb);
  }

  this._sendRouter([idBuf, msg.raw()]);

  return this;
};

/**
 * Send a message to all nodes that are listening for message of type &#x60;type&#x60;.
 *
 * If you are expecting a reply, pass in a callback.
 *
 * @param  {String}   type
 * @param  {Object}   data
 * @param  {Function} [cb]
 * @return {Node}
 * @chainable
 */
Node.prototype.sendAll = function (type, data, cb) {
  var msg = this._msgFactory.build({
    dest: &#x27;_all&#x27;,
    type: type,
    data: data
  });

  if (cb) {
    // TODO: since multiple nodes will be receiving our message
    // cb should be called with a stream
    this._addReplyHandler(msg, cb);
  }

  this._sendPub(msg.raw());

  return this;
};

/**
 * Send a reply to a message.
 *
 * TODO: refactor this and &#x60;.sendTo&#x60;
 *
 * @param {Object}    origMsg   The message that we want to reply to
 * @param {Object}    data      Data that we want to send
 * @param {Function}  cb        Called with &#x60;(error, [reply])&#x60;
 */
Node.prototype.reply = function (origMsg, data, cb) {
  if (!this._cluster[origMsg.src]) {
    return cb(new Error(&#x27;no such node&#x27;));
  }

  if (arguments.length === 2) {
    cb = data;
    data = undefined;
  }

  var idBuf = Node.buildSocketId(origMsg.src);
  var msg = this._msgFactory.build({
    dest: origMsg.src,
    type: &#x27;_reply&#x27;,
    data: data,
    parent: origMsg.id
  });

//  this._logInfo(&#x27;reply():&#x27;);
//  this._logInfo(arguments);

  if (cb.length === 2) {
    this._addReplyHandler(msg.body(), cb);
  }

  this._sendRouter([idBuf, msg.raw()]);
};

/**
 * Returns information about this node.
 *
 * @return {Object}
 */
Node.prototype.getInfo = function () {
  return {
    id: this.id,
    name: this.name,
    endpoints: this.endpoints,
    keepalive: this.keepalive,
    messages: this.messages
  };
};

/**
 * Get the messages that the node is listening on.
 */
Node.prototype.messages = function () {
  return
};

/*********************************************
 * Private API
 *********************************************/

/**
 * Initialze listeners for protocol messages.
 *
 * @private
 */
Node.prototype._initListeners = function () {
  this.on(&#x27;_join&#x27;, this._onJoin.bind(this));
  this.on(&#x27;_reply&#x27;, this._onReply.bind(this));
  this.on(&#x27;_connect&#x27;, this._onConnect.bind(this));
  this.on(&#x27;_ka&#x27;, this._onKeepalive.bind(this));
  this.on(&#x27;_leave&#x27;, this._onLeave.bind(this));
};

/**
 * Initializes the pub and router sockets.
 *
 * @return {Node}
 * @private
 */
Node.prototype._initSockets = function () {
  this._routerSocket.setsockopt(zmq.options.identity, this.socketId);
  this._routerSocket.setsockopt(zmq.ZMQ_SNDHWM, 100000);
  this._routerSocket.setsockopt(zmq.ZMQ_RCVHWM, 100000);
  this._routerSocket.setsockopt(zmq.ZMQ_SNDBUF, 100000);
  this._routerSocket.setsockopt(zmq.ZMQ_RCVBUF, 100000);
  this._routerSocket.bindSync(this.endpoints.router);
  this._routerSocket.on(&#x27;message&#x27;, this._onRouterMessage.bind(this));

  this._r2 = zmq.socket(&#x27;router&#x27;);
  this._r2.on(&#x27;message&#x27;, this._onRouterMessage.bind(this));

  this._pubSocket.bindSync(this.endpoints.pub);
  this._subSocket.on(&#x27;message&#x27;, this._onSubMessage.bind(this));
};

/**
 * Called when the sub socket receives a message.
 *
 * Messages that node hasn&#x27;t subscribed to with &#x60;.on()&#x60; will be ignored.
 *
 * Emits an event of type &#x60;msg.type&#x60; with the message.
 *
 * @param frame
 * @private
 */
Node.prototype._onSubMessage = function (frame) {
  var msg = new Message(frame);
  var body = msg.body();

  if (this._subscribedTo(body.type)) {
    this._msgEmitter.emit(body.type, body);
  }

//  this._log(&#x27;info&#x27;, &#x27;_onSubMessage(): received sub message&#x27;)
//  this._log(&#x27;info&#x27;, frame.toString());
};

/**
 * Called when the node receives a message on router socket.
 *
 * @private
 */
Node.prototype._onRouterMessage = function (id, message) {
  var msg = new Message(message);
  var body = msg.body();

//  this._logInfo(&#x27;_onRouterMessage(): received from %s:&#x27;, id.toString());
//  this._logInfo(body);

  if (this.messages[body.type]) {
    this._msgEmitter.emit(body.type, body);
  }
};

Node.prototype._onReply = function (body) {
//  this._logInfo(this._pendingReplies);
//  this._logInfo(&#x27;_onReply(): got reply:\n%j&#x27;, body);
  if (!this._pendingReplies[body.parent]) {
    return;
  }

//  console.log(body);

//  this._logInfo(this._pendingReplies[body.parent].cbs[0].toString());

  var self = this;

  this._pendingReplies[body.parent].cbs.forEach(function (fn) {
    fn.call(self, null, body);
  });
};

Node.prototype._onJoin = function (body) {
  var self = this;

  this._addNodeToCluster(body.data);

  var data = { cluster: this._cluster, me: this.getInfo() };

  this.reply(body, data, function (err) {
    if (err) {
      self._logError(&#x27;failed to reply to _join:&#x27;);
      self._logError(err.stack);
    }
  });
};

Node.prototype._onConnect = function (msg) {
  var self = this;
  var data = this.getInfo();

  this._addNodeToCluster(msg.data);

  this.reply(msg, data, function (err) {
    if (err) {
      self._log(&#x27;error&#x27;, &#x27;failed to reply to _connect:&#x27;);
      self._log(&#x27;error&#x27;, err.stack);
    }
  });
};

Node.prototype._onLeave = function (msg) {
  this._disconnectNode(this._cluster[msg.src]);
  this._removeNodeFromCluster(msg.src);
};

Node.prototype._onKeepalive = function (msg) {
  var id = msg.src;
  this._clusterKeepalive[id] = Date.now() + this._cluster[id].keepalive.period;
};

/**
 * Handles delayed &#x60;.connect()&#x60; calls that were made before calling &#x60;.start()&#x60;.
 *
 * @private
 */
Node.prototype._drainConnectQueue = function () {
  var self = this;
  var args = self._connectQueue.shift();

  if (args) {
    self.join.apply(self, args);
    if (self._connectQueue.length) {
      self._drainConnectQueue();
    }
  }
};

/**
 * Add a node to our cluster.
 *
 * @param     {Object|Node}   node
 * @param     {String}        node.id
 * @param     {String}        node.name
 * @param     {String}        node.endpoints.router
 * @param     {String}        node.endpoints.pub
 * @param     {String}        node.keepalive.period
 * @param     {Object}        node.messages
 *
 * @private
 */
Node.prototype._addNodeToCluster = function (node) {
  var self = this;

  if (this.id === node.id) {
    return;
  }

  if (!this._cluster[node.id]) {
    // new node
    this._connectRouter(node.endpoints.router);
    this._connectSub(node.endpoints.pub);
    this._connectedTo[node.id] = 1;
    if (!node.messages) {
      node.messages = {
        _join: {
          period: this._defaultReplyPeriod,
          attempts: this._defaultReplyAttempts
        },
        _leave: {
          period: this._defaultReplyPeriod,
          attempts: this._defaultReplyAttempts
        },
        _connect: {
          period: this._defaultReplyPeriod,
          attempts: this._defaultReplyAttempts
        },
        _ka: {
          period: this._defaultReplyPeriod,
          attempts: this._defaultReplyAttempts
        },
        _reply: {
          period: this._defaultReplyPeriod,
          attempts: this._defaultReplyAttempts
        }
      };
    }
    this._cluster[node.id] = node;
    this._cluster[node.id].socketId = Node.buildSocketId(node.id);
  } else {
    // existing node

    // update messages
    keys(node.messages).forEach(function (type) {
      self._cluster[node.id].messages[type] = node.messages[type];
    });

    // update keepalive
    self._cluster[node.id].keepalive.period = node.keepalive.period;

    // update name
    self._cluster[node.id].name = node.name;
  }

//  this._logInfo(&#x27;cluster:&#x27;);
//  this._logInfo(this._cluster);

  // add node to &#x60;_clusterByMsg&#x60;
  keys(node.messages).forEach(function (type) {
    if (!self._clusterByMsg[type]) {
      self._clusterByMsg[type] = [];
    }
    if (self._clusterByMsg[type].indexOf(node) === -1) {
      self._clusterByMsg[type].push(node);
    }
  });

  // refresh keepalive
  this._clusterKeepalive[node.id] = Date.now() + node.keepalive.period;
};

Node.prototype._removeNodeFromCluster = function (id) {
  var self = this;
  var node = this._cluster[id];

  if (!node) {
    return;
  }

  this._disconnectRouter(node.endpoints.router);
  this._disconnectSub(node.endpoints.pub);

  keys(node.messages).forEach(function (type) {
    self._clusterByMsg[type].splice(self._clusterByMsg.indexOf(node), 1);
  });

  delete this._connectedTo[id];
  delete this._clusterKeepalive[id];
  this._disconnectNode(node);

  delete this._cluster[id];
};

Node.prototype._updateNode = function (id, data) {

};

/**
 *
 * @param {String}    type
 * @param {Function}  cb
 * @chainable
 * @private
 */
Node.prototype._on = function (type, cb) {
  this._internalEmitter.on(type, cb);
};

Node.prototype._off = function (type, cb) {
  if (cb) {
    this._internalEmitter.removeListener(type, cb);
  } else if (type) {
    this._internalEmitter.removeAllListeners(type);
  } else {
    this._internalEmitter.removeAllListeners();
  }
};

/**
 * Emit an internal event.
 *
 * @return {Node}
 * @private
 */
Node.prototype._emit = function () {
  this._internalEmitter.emit.apply(this._internalEmitter, arguments);
  return this;
};

/**
 * Attach a reply handler to a message.
 *
 * @param  {Object}   msg
 * @param  {Function} cb
 * @return {Node}
 * @chainable
 * @private
 */
Node.prototype._addReplyHandler = function (msg, cb) {
  if (!this._pendingReplies[msg.id]) {
    this._pendingReplies[msg.id] = {
      msg: msg,
      cbs: []
    };
  }
  this._pendingReplies[msg.id].cbs.push(cb);

  return this;
};

/**
 * Call reply handlers of a message.
 *
 * @param   {String}    id      The id of the message
 * @param   {Object}    reply   The reply message
 * @param   {Function}  [cb]    Optional callback
 * @return  {Node}
 * @chainable
 * @private
 */
Node.prototype._callReplyHandlers = function (id, reply, cb) {
  var self = this;

  this._pendingReplies[id].cbs.forEach(function (fn) {
    fn.call(self, reply);
  });

  cb();

  return this;
};

/**
 * Send a message from the PUB socket. Messages are automatically
 * queued to prevent the slow joiner symptom (missing messages on
 * subscribers due to TCP handshake delay).
 *
 * @param   {String|Buffer|Array} msg The data to send
 * @return  {Node}
 * @chainable
 * @private
 */
Node.prototype._sendPub = function (msg) {
  if (this._shouldQueuePub) {
    this._pubQueue.push(msg);
  } else {
    this._pubSocket.send(msg);
  }

  return this;
};

/**
 * Send a message from the router socket.
 *
 * @param  {Array} frames Must be [id, message]
 */
Node.prototype._sendRouter = function (frames) {
//  if (Math.random() &gt; 0.5) {
    this._routerSocket.send(frames);
//  } else {
//    this._r2.send(frames);
//  }
  return this;
};

/**
 * Closes all the sockets.
 *
 * @return {Node}
 * @chainable
 * @private
 */
Node.prototype._closeSockets = function () {
  var self = this;

  this._logInfo(&#x27;_closeSockets(): closing sockets&#x27;);

  self._routerSocket.close();
  self._pubSocket.close();
  self._subSocket.close();

  return this;
};

Node.prototype._connectRouter = function (endpoint) {
  this._logInfo(&#x27;_connectRouter(): connecting to&#x27;, endpoint);
  this._routerSocket.connect(endpoint);
  this._r2.connect(endpoint);
  return this;
};

Node.prototype._connectSub = function (endpoint) {
  this._logInfo(&#x27;_connectSub(): connecting to&#x27;, endpoint);
  this._subSocket.connect(endpoint);
  return this;
};

Node.prototype._disconnectRouter = function (endpoint) {
  this._logInfo(&#x27;_disconnectRouter(): disconnecting from&#x27;, endpoint);
  this._routerSocket.disconnect(endpoint);
  return this;
};

Node.prototype._disconnectSub = function (endpoint) {
  this._logInfo(&#x27;_disconnectSub(): disconnecting from&#x27;, endpoint);
  this._subSocket.disconnect(endpoint);
  return this;
};

Node.prototype._clearPubQueue = function () {
  if (this._shouldQueuePub) {
    var self = this;
    this._shouldQueuePub = false;
    this._pubQueue.forEach(function (frame) {
      self._sendPub(frame);
    });
  }
};

/**
 * @param   {String} level    &#x60;error&#x60; or &#x60;info&#x60;
 * @param   {String|Object} args*
 * @return  {Node}
 * @private
 * @chainable
 */
Node.prototype._log = function (level, args) {
  args = [].slice.call(arguments, 1);
  var stack = __stack();
  var line = stack[2].getLineNumber();
  var file = stack[2].getFileName();

  var prefix = file + &#x27;:&#x27; + line + &#x27; &#x27; + new Date().toISOString() + &#x27; &#x27; + this.id + &#x27;: &#x27;;

  if (typeof args[0] === &#x27;string&#x27;) {
    args[0] = prefix + args[0];
  } else {
    args.unshift(prefix);
  }

  if (level === &#x27;info&#x27;) {
    console.log.apply(console, args);
  } else {
    console.error.apply(console, args);
  }

  return this;
};

/**
 * @private
 */
Node.prototype._logError = function () {
  var args = [].slice.call(arguments);
  args.unshift(&#x27;error&#x27;);
  this._log.apply(this, args);
};

/**
 * @private
 */
Node.prototype._logInfo = function () {
  var args = [].slice.call(arguments);
  args.unshift(&#x27;info&#x27;);
  this._log.apply(this, args);
};

/**
 *
 * @param   {String} id
 * @return  {Buffer}
 * @static
 */
Node.buildSocketId = function (id) {
  var socketId = &#x27;z&#x27; + id;
  var buffer = new Buffer(socketId);
  return buffer;
};

Node.STOPPED = 0;
Node.STARTED = 1;
Node.JOINING = 2;
Node.JOINED = 3;
Node.READY = 4;

/**
 * How often this node will notify the cluster of it&#x27;s aliveness, in milliseconds.
 *
 * @property  DEFAULT_KEEPALIVE_PERIOD
 * @type      Number
 * @default   1000
 * @static
 */
Node.DEFAULT_KEEPALIVE_PERIOD = 1000;

module.exports = Node;

if (require.main === module) {
  var nodeA = new Node({ id: &#x27;A&#x27; });
  var nodeB = new Node({ id: &#x27;B&#x27; });
  var got = 0;

  nodeB.on(&#x27;keke&#x27;, function () {
    got += 1;
  });

  nodeA.start();
  nodeB.start();

  console.log(&#x27;node A socket id:&#x27;, nodeA.socketId.toString(), nodeA.socketId);
  console.log(&#x27;node B socket id:&#x27;, nodeB.socketId.toString(), nodeB.socketId);

  nodeA.join(nodeB, function (err) {
    if (err) {
      console.log(err.stack);
    } else {
      console.log(&#x27;connected to node&#x27;, nodeB);
    }
  });

  setTimeout(function () {
    console.log(&#x27;got: &#x27;, got);
    console.log(&#x27;attempted: &#x27;, attempted);
    nodeA.stop();
    nodeB.stop();
  }, 10000);

  var attempted = 0;

//  setInterval(function () {
////    nodeA.stop();
////    nodeB.stop();
//    nodeA.sendTo(nodeB.id, &#x27;keke&#x27;, {kekekeke: true});
//    attempted += 1;
//  }, 0);

  process.nextTick(function () {
    var d1 = Date.now();

    for (var i = 0; i &lt; 100000100; i++) {
      nodeA.sendTo(nodeB.id, &#x27;keke&#x27;, {kekekeke: true});
      attempted += 1;
    }

    console.log(&#x27;tool&#x27;, Date.now() - d1, &#x27;ms&#x27;);
  });

//  while (true) {
//    nodeA.sendTo(nodeB.id, &#x27;keke&#x27;, {kekekeke: true});
//  }
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
