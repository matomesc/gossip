<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/hub.js - Gossip</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Gossip"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Cluster.html">Cluster</a></li>
            
                <li><a href="../classes/Hub.html">Hub</a></li>
            
                <li><a href="../classes/Message.html">Message</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/utils.html">utils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/core.html">core</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: core/hub.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var EventEmitter = require(&#x27;events&#x27;).EventEmitter;
var inherits = require(&#x27;util&#x27;).inherits;
var zmq = require(&#x27;zmq&#x27;);
var retry = require(&#x27;retry&#x27;);
var Stately = require(&#x27;stately.js&#x27;);
var Message = require(&#x27;./message.js&#x27;);
var MessageFactory = require(&#x27;./message_factory&#x27;);
var utils = require(&#x27;./utils&#x27;);

/**
 * The &#x60;Hub&#x60; abstracts low level ZeroMQ communication.
 *
 * Features:
 *
 * - 1-1, 1-N req / rep
 * - message acknowledgements
 * - retries
 * - keepalives
 *
 * It three ZMQ sockets: router, pub and sub.
 *
 * @class   Hub
 * @extends EventEmitter
 * @module  core
 * @param   {Object}  options
 * @param   {String}  [options.id]      Uniquely identifies the hub on the network.
 * @param   {String}  options.router    Router socket endpoint. Supports all the ZeroMQ socket endpoints.
 * @param   {String}  [options.pub]     Pub socket endpoint.
 * @constructor
 */
function Hub(options) {
  EventEmitter.call(this);

  this.debug = false;

  this.id = options.id || &#x27;hub-&#x27; + utils.randomId();
  this.routerEndpoint = options.router;
  this.routerEndpointType = utils.endpointType(this.routerEndpoint);
  this.pubEndpoint = options.pub;
  this.pubEndpointType = this.routerEndpointType;

  if (!this.pubEndpoint) {
    var pieces = this.routerEndpoint.split(&#x27;:&#x27;);

    if (this.routerEndpointType === &#x27;tcp&#x27;) {
      var port = utils.randRange(5000, 1 &lt;&lt; 16);
      this.pubEndpoint = [pieces[0], pieces[1], port].join(&#x27;:&#x27;);
    } else {
      this.pubEndpoint = [pieces[0], &#x27;/tmp/pub-&#x27; + this.id];
    }
  }

  // these are lazily initiated in &#x60;.bind()&#x60;
  this.routerSocket = null;
  this.pubSocket = null;
  this.subSocket = null;

  this.connectTimeout = options.connectTimeout || 1000;
  this.connectAttempts = options.connectAttempts || 3;
  this.connectPeriod = options.connectPeriod || 200;

  /**
   * The id of the hub&#x27;s router socket. Other nodes use this to send messages us messages from their router sockets.
   *
   * @property  routerSocketId
   * @type      {Buffer}
   * @default   null
   */
  this.routerSocketId = null;

  /**
   * Whether all messages that this node sends should be &#x60;ack&#x60;ed.
   *
   * @property   ackAll
   * @type      {Boolean}
   * @default   true
   */
  this.ackAll = true;

  /**
   * Messages types which the node should &#x60;ack&#x60;. Overrides &#x60;ackAll&#x60;.
   *
   * @property   ackOnly
   * @type      {Object}
   * @default   {}
   */
  this.ackOnly = {};

  /**
   * The hub&#x27;s message factory. Used to create all messages sent.
   *
   * @property  messageFactory
   * @type      {MessageFactory}
   */
  this.messageFactory = new MessageFactory({
    id: utils.randomId,
    src: this.id
  });

  /**
   * The hub&#x27;s state machine.
   *
   * @property  _machine
   * @type      {Stately}
   * @private
   */
  this._machine = new Stately({
    CLOSED: {
      bind: &#x27;BOUND&#x27;
    },
    BOUND: {
      close: &#x27;CLOSED&#x27;
    }
  }, &#x27;CLOSED&#x27;);

  this._pendingAcks = {};
  this._pendingReplies = {};

  this._pendingAcksByTime = [];
  this._pendingAcksPruner = null;

  this._ops = {
    fast: Hub.op({
      retries: 10,
      minTimeout: 100,
      maxTimeout: 1000
    }),
    medium: Hub.op({
      retries: 10,
      minTimeout: 1000,
      maxTimeout: 10 * 1000
    }),
    slow: Hub.op({
      retries: 10,
      minTimeout: 30 * 1000,
      maxTimeout: 3 * 60 * 1000
    })
  };

  this._connectedHubs = {};
  this._connectedRouterEndpoints = {};
  this._connectedSubEndpoints = {};
}
inherits(Hub, EventEmitter);

/**
 * Bind the router and pub sockets. The hub can now send/receive messages.
 *
 * @method  bind
 */
Hub.prototype.bind = function () {
  var state = this._machine.getMachineState();
  if (state !== &#x27;CLOSED&#x27;) {
    return;
  }

  // create sockets
  this.routerSocket = zmq.socket(&#x27;router&#x27;);
  this.pubSocket = zmq.socket(&#x27;pub&#x27;);
  this.subSocket = zmq.socket(&#x27;sub&#x27;);

  // generate router socket id
  this.routerSocketId = Hub.routerSocketId(this.id);

  // set router socket identity
  this.routerSocket.setsockopt(zmq.options.identity, this.routerSocketId);
  this.routerSocket.setsockopt(zmq.ZMQ_LINGER, 0);

  // throw errors if messages sent can&#x27;t be routed
//  this.routerSocket.setsockopt(zmq.ZMQ_ROUTER_MANDATORY, 1);

  // bind sockets
  try {
    this.routerSocket.bindSync(this.routerEndpoint);
  } catch (e) {
    console.log(&#x27;failed to bind router: attempted&#x27;, this.routerEndpoint);
    throw e;
  }

  try {
    this.pubSocket.bindSync(this.pubEndpoint);
  } catch (e) {
    console.log(&#x27;failed to bind pub: attempted&#x27;, this.routerEndpoint);
    throw e;
  }

  var self = this;
  function routeMessage(msg) {
    var type = msg.get(&#x27;type&#x27;);

    if (type === &#x27;_ack&#x27;) {
      self.onAck(msg);
    } else if (type === &#x27;_handshake&#x27;) {
      self.onHandshake(msg);
    } else if (type === &#x27;_reply&#x27;) {
      self.onReply(msg);
    }

    self.emit(type, msg);
  }

  // set message handlers
  this.routerSocket.on(&#x27;message&#x27;, function (id, delimiter, data) {
    if (self.debug) {
      console.log(&#x27;%s: RECV ROUTER&#x27;, self.id);
      console.log([].map.call(arguments, function (f) {
        return f.toString();
      }));
      //    console.log(&#x27;%s: REPLY HANDLERS&#x27;, self.id);
      //    console.log(self._pendingReplies);
    }

    var message = new Message(data);
    routeMessage(message);
  });

  this.pubSocket.on(&#x27;message&#x27;, function () {
    console.log(&#x27;pub message:&#x27;);
    console.log(arguments);
  });

  this._startAckPruner();

  this._machine.bind();

  return this;
};

Hub.prototype.close = function (callback) {
  this._machine.close();

  if (this._machine.getMachineState() !== &#x27;CLOSED&#x27;) {
    return;
  }

  var self = this;

  // note: socket.close() is async
  if (self.routerSocket) {
    self.routerSocket.close();
    self.routerSocket = null;
  }

  if (self.pubSocket) {
    self.pubSocket.close();
    self.pubSocket = null;
  }

  if (self.subSocket) {
    self.subSocket.close();
    self.subSocket = null;
  }

  self._stopAckPruner();

  process.nextTick(function () {
    if (callback) {
      callback();
    }
  });
};

/**
 * Connect the hub to another hub.
 *
 * @method  handshake
 * @param   {Hub}       hub       The hub to connect to.
 * @param   {Function}  callback  Called after completing the handshake.
 */
Hub.prototype.handshake = function (hub, callback) {
  var self = this;
  var message = this.messageFactory.build({
    type: &#x27;_handshake&#x27;,
    data: {
      id: this.id,
      router: this.routerEndpoint,
      pub: this.pubEndpoint
    }
  });

  function handleReply(err, msg) {
    if (err) {
      self._disconnectRouter(hub.routerEndpoint);
      return console.log(&#x27;error handshaking:\n&#x27;, err.stack);
    }

    hub.id = msg.get(&#x27;data.id&#x27;);
    hub.pubEndpoint = msg.get(&#x27;data.pub&#x27;);

    self._connectSub(hub.pubEndpoint);
    self._connectedHubs[hub.id] = hub;

    callback();
  }

  this._addAckHandler(message);
  this._addReplyHandler(message, handleReply);

  // need to connect router in order to receive reply
  self._connectRouter(hub.routerEndpoint);

  // send the handshake message
  var socket = zmq.socket(&#x27;req&#x27;);
  socket.connect(hub.routerEndpoint);
  socket.send(message.serialize());
  socket.close();
};

/**
 * Called when the hub receives a &#x60;_handshake&#x60; message.
 *
 * @method onHandshake
 * @param  {Message}    msg
 */
Hub.prototype.onHandshake = function (msg) {
  var data = msg.get(&#x27;data&#x27;);

  var hub = new Hub({
    id: data.id,
    pub: data.pub,
    router: data.router
  });

  this._connectRouter(hub.routerEndpoint);
  this._connectSub(hub.pubEndpoint);

  this._connectedHubs[hub.id] = hub;

  this.ack(msg);

  this.reply(msg, {
    id: this.id,
    router: this.routerEndpoint,
    pub: this.pubEndpoint
  });
};

/**
 * Acknowledge the receival of a message by sending an &#x60;_ack&#x60; message.
 *
 * @method  ack
 * @param   {Message} msg
 */
Hub.prototype.ack = function (msg) {

  this.sendById(msg.get(&#x27;src&#x27;), this.messageFactory.build({
    type: &#x27;_ack&#x27;,
    parent: msg.get(&#x27;id&#x27;)
  }));
};

Hub.prototype.onAck = function (msg) {
  if (this._pendingAcks[msg.id]) {
    this._pendingAcks[msg.id].fulfilled = true;
    delete this._pendingAcks[msg.id];
  }
};

/**
 * Reply to a message. Pass in a callback if you&#x27;re expecting a reply.
 *
 * @method  reply
 * @param   {Object}    msg     The message you are replying to.
 * @param   {Object}    [data]  Optional data to send
 * @param   {Function}  [callback]
 */
Hub.prototype.reply = function (msg, data, callback) {
  var src = msg.get(&#x27;src&#x27;);
  var id = msg.get(&#x27;id&#x27;);

  var reply = this.messageFactory.build({
    parent: id,
    type: &#x27;_reply&#x27;
  });

  if (arguments.length === 2 &amp;&amp; typeof data === &#x27;function&#x27;) {
    callback = data;
    data = undefined;
  }

  if (data !== undefined) {
    reply.set(&#x27;data&#x27;, data);
  }

  this._sendRouter([
    Hub.routerSocketId(src),
    utils.EMPTY_BUFFER,
    reply.serialize()
  ]);

  if (callback) {
    this._addAckHandler(reply);
    this._addReplyHandler(reply, callback);
  }
};

Hub.prototype.onReply = function (msg) {
  var parent = msg.get(&#x27;parent&#x27;);

  if (this._pendingReplies[parent]) {
    this._pendingReplies[parent].cb.forEach(function (cb) {
      cb(null, msg);
    });
    delete this._pendingReplies[parent];
  }
};

/**
 * Send a message to the hub identified by &#x60;id&#x60;.
 *
 * @method  sendById
 * @param   {String}    id
 * @param   {Message}   message
 * @param   {Function}  [callback]  If you are expecting a reply, this will be called with &#x60;(err, reply)&#x60;.
 */
Hub.prototype.sendById = function (id, message, callback) {
  // TODO: figure out retry logic
  if (callback) {
    this._addReplyHandler(message, callback);
    this._addAckHandler(message);
  }

  this._sendRouter([
    Hub.routerSocketId(id),
    utils.EMPTY_BUFFER,
    message.serialize()
  ]);
};

/**
 * Connect the router socket to an endpoint.
 *
 * @param   {String} endpoint
 * @private
 */
Hub.prototype._connectRouter = function (endpoint) {
  if (!this._connectedRouterEndpoints[endpoint]) {
    this.routerSocket.connect(endpoint);
    this._connectedRouterEndpoints[endpoint] = 1;
  }
};

Hub.prototype._disconnectRouter = function (endpoint) {
  if (this._connectedRouterEndpoints[endpoint]) {
    this.routerSocket.disconnect(endpoint);
    delete this._connectedRouterEndpoints[endpoint];
  }
};

Hub.prototype._isRouterConnectedTo = function (endpoint) {
  return this._connectedRouterEndpoints[endpoint] === 1;
};

Hub.prototype._connectSub = function (endpoint) {
  if (!this._connectedSubEndpoints[endpoint]) {
    this.subSocket.connect(endpoint);
    this._connectedSubEndpoints[endpoint] = 1;
  }
};

Hub.prototype._disconnectSub = function (endpoint) {
  if (this._connectedSubEndpoints[endpoint]) {
    this.subSocket.disconnect(endpoint);
    delete this._connectedSubEndpoints[endpoint];
  }
};

Hub.prototype._isSubConnectedTo = function (endpoint) {
  return this._connectedSubEndpoints === 1;
};

/**
 * Send an array of buffers on the router socket.
 *
 * The first frame **must** be the socket of the other hub.
 *
 * @method _sendRouter
 * @param  {Array}    frames    Array of &#x60;Buffer&#x60;s.
 * @private
 */
Hub.prototype._sendRouter = function (frames) {
  if (this.debug) {
    console.log(&#x27;%s: SEND ROUTER&#x27;, this.id);
    console.log(frames.map(function (f) {
      return f.toString();
    }));
    //  console.log(&#x27;%s: REPLY HANDLERS&#x27;, this.id);
    //  console.log(this._pendingReplies);
  }

  this.routerSocket.send(frames);
};

/**
 * Send a buffer on the pub socket.
 *
 * @method _sendPub
 * @param  {Buffer} buffer
 * @private
 */
Hub.prototype._sendPub = function (buffer) {
  this.pubSocket.send(buffer);
};

Hub.prototype._addAckHandler = function (msg) {
  var ack = {
    expires: Date.now() + 100,
    fulfilled: false
  };

  this._pendingAcks[msg.get(&#x27;id&#x27;)] = ack;
  this._pendingAcksByTime.push(ack);
};

Hub.prototype._addReplyHandler = function (msg, callback) {
  var id = msg.get(&#x27;id&#x27;);

  if (!this._pendingReplies[id]) {
    this._pendingReplies[id] = {
      cb: []
    };
  }

  this._pendingReplies[id].cb.push(callback);
};

Hub.prototype._startAckPruner = function () {
  var self = this;
  this._pendingAcksPruner = setInterval(function () {
    var now = Date.now();
    var acks = self._pendingAcksByTime;
    var ack;

    while (acks.length &amp;&amp; acks[0].expires &lt; now) {
      ack = self._pendingAcksByTime.shift();

      if (!ack.fulfilled) {
        // TODO: implement retry logic here
        console.log(&#x27;%s: ack not fulfilled... should retry&#x27;, self.id);
      }
    }
  }, 1000);
};

Hub.prototype._stopAckPruner = function () {
  if (this._pendingAcksPruner) {
    clearInterval(this._pendingAcksPruner);
  }
};

/**
 * @method  routerSocketId
 * @param   {String} id
 * @return  {Buffer}
 * @static
 */
Hub.routerSocketId = function (id) {
  var socketId = &#x27;g&#x27; + id;
  return new Buffer(socketId);
};

/**
 * @method  op
 * @param   {Object}          options   Same options as &#x60;retry.operation(options)&#x60;
 * @returns {RetryOperation}
 * @static
 */
Hub.op = function (options) {
  var opKey = Object.keys(options).join(&#x27;|&#x27;);
  if (!Hub._opCache[opKey]) {
    Hub._opCache[opKey] = retry.operation(options);
  }
  return Hub._opCache[opKey];
};

/**
 * Caches operations returned by &#x60;Hub.op()&#x60;.
 *
 * @property  _opCache
 * @type      {Object}
 * @private
 * @static
 */
Hub._opCache = {};

module.exports = Hub;

if (require.main === module) {
  var a = new Hub({
    id: &#x27;a&#x27;,
    router: &#x27;tcp://127.0.0.1:5000&#x27;
  }).bind();
  var b = new Hub({
    id: &#x27;b&#x27;,
    router: &#x27;tcp://127.0.0.1:6000&#x27;
  }).bind();

  a.handshake(b, function (err) {
    console.log(&#x27;done&#x27;);
    a.close();
    b.close();
  });
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
